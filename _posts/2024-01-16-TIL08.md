---
title: "[TIL] 240116"
excerpt: "240116 TIL 게시글입니다."

writer: Audrey
categories: [TIL, "2024"]

toc: true
toc_sticky: true

date: 2024-01-16 20:58:00 +09:00
last_modified_at: 2024-01-16 20:58:00 +09:00

tags: [til]
---

# Object 클래스

- 코드를 짜면서, equals 라던가, toString메소드를 본적이 있다. 클래스에 안에 분명 메소드를 정의한 기억이 없는데 왜 사용이 가능한 것일까? → 모두 Object  클래스에 정의되어 있기 때문이다.

- Object 클래스는 모든 클래스들의 최상위 부모 클래스이다. extends 키워드를 명시하지 않으면 기본적으로 Object 클래스를 상속한다고 볼 수 있다.
- 그런데 equals는 기본적으로 객체와 변수들의 참조값을 비교해서 결론을 내린다.
- 이름과 학번이 같은 객체를 두개 만들어서 서로 비교하면 자바는 어떻게 생각할까? 당연히 다르니까 false라는 결과를 내린다. 메모리에서 두 객체의 참조값이 다르기 때문이다. 만약 이 학생들이 같은 학생이야. 라는 것을 자바에게 알려주고 싶다면? → equals 메소드를 오버라이드 하면 된다!
- 오버라이드가 뭐였냐면… 상속에서 쓰이는 개념이다.
    - 자식 클래스는 부모 클래스의 메소드를 가져와서 자유롭게 쓸 수 있다. 이때 자식클래스가 부모 클래스의 메소드를 **오버라이드** 한다고 한다.
- Object클래스에서 자주 쓰이는 메소드들에는 뭐가 있을까?
    - equals : 두 객체가 동등한가? 기본적으로 두 객체의 참조값을 비교한다.
    - toString() : 객체의 해시 코드를 반환함.
    - hashCode() : 객체를 문자열로 표현하는데 사용한다.
    - getClass() : 객체의 클래스 정보를 반환한다.

# 예외처리

- 개발하다보면 수많은 에러들을 만나게 된다. 단순히 로그인 과정을 구현한다고 치자. 개발자가 생년월일을 6자로 적게끔 설정해두어도 꼭 누군가는 8자로 적는다. 이런 예외 상황을 어떻게 처리할까? 이러한 상황을 처리하는 것을 예외처리라고 한다. 다시 말해 비정상적인 프로그램의 종료를 막기 위해서 예외 처리를 한다.

## try-catch

- 자바에서 기본적인 예외처리는 try-catch문을 사용한다. try안에는 실행문을, catch의 인자에는 에러명, 블록 안쪽에는 예외처리 구문을 작성한다.
- 말그대로 실행문을 시도하고, 예외가 생기면 예외를 잡아서 처리한다는 의미이다.
- 그러나 오류의 형태는 다양하고, 종류도 다양할 수 있다. 그럴때는 하나의 블록에 여러 개의 catch 블록을 추가할 수 있다. 이때 주의할 점은 예외 클래스들 간의 상속 관계를 이해하는 것이 먼저이다.
    - 왜냐하면 에러 클래스들간에도 상속 관계가 있다. 예를 들어 NumberFormatException은 RuntimeException을 상속받는다.
    - 만약 위에 RuntimeException에 대한 에러 처리를 하고 아래 catch 블록에서 NumberFormatException에 대한 에러처리를 하게끔 코드를 작성했다고 치자.
    - 이렇게 된다면 RuntimeException이 먼저 모든 에러처리를 진행해버린다. → 특정 에러에 대한 처리를 따로 진행하고 싶다면? 둘이 순서를 바꿔 주면 된다.
    - 다시 말해서 부모를 아래에 두면 된다.
- 꼭 실행하고 싶은 구문이 있다면 마지막 블록에 finally를 추가해서 꼭 실행해야하는 구문을 안에 넣어주면 된다.

## checked? unchecked?

- 우리가 그냥 작성한 코드를 생각해보자. 문제가 생기면 에러가 생기고 무슨 종류의 에러인지 콘솔에 뜬다. 우리가 예외처리를 한적이 없는데 어떻게 된 것일까?
- 그것들은 모두 unchecked 이다. 다시 말해 try-catch문이 없어도 동작하는 예외클래스를 말한다. RuntimeException을 의미한다.
- 그렇다면 당연하게도, unchecked는 try-catch와 같은 예외 처리 코드가 없으면 동작하지 않는 예외를 뜻한다.

## throw

- throw는 던지다 라는 뜻이다. 자바에서 예외가 발생할때 직접 처리하지 않고 throw, 던지겠다는 뜻이다.
- 이때 직접 예외 객체를 만들어서 던진다. 자바는 자동으로 이걸 처리하지만 그렇지 않는 예외의 경우, throw문으로 직접 던져야 한다.
- 만약 최고점수가 100점인 score변수의 값에 따라 A, B, C, D, E의 등급을 나누어주는 if문이 있다고 치자. 만약에 score의 값에 음수 혹은 100보다 큰 숫자가 들어온다면? 개발자는 물론 이거 잘못된 값이네~하고 생각하겠지만 자바는 아니다. 자바는 지극히 정상적인 결과로 판단한다.
- 그러므로 위의 경우, throw문을 이용해서 처리해야 한다.

```java
if(score < 0 || score > 100) {
		throw new RuntimeException();
} 
```

- 위와 같이 RuntimeException 객체를 생성해서 예외를 던져준다. 만약 이 throw문이 try안에 있다면 이 던진 예외는 어디로 가는가?(던지면 받는 곳이 있어야 한다..)
- 바로 하단의 catch문에서 받게 된다.

## throws

- throw와 다른점이 무엇인가? 이것도 마찬가지로 예외를 던지지만….던지는 곳이 다르다.
- throws는 메소드에서 발생한 예외를 메소드를 호출한 곳으로 던질때 사용한다.
- 그러므로 당연히~ 메소드를 호출한 곳에서는 예외처리코드가 추가되어야 할 것이다.

```java
public void addNum(int a, int b) throws ArithmeticException {
		System.out.println(a+b);
}
```

- 위처럼 메소드 이름 옆에서 메소드를 호출하는 곳으로 예외를 던진다.

### 사용자 예외 메시지

- 그렇다면 내가 예외 메시지를 직접 바꿀 수는 없을까? → 가능하다!
- 예외를 던질때 예외 옆 인자에 메시지를 적어주면 된다.

### 사용자 예외 클래스

- 자바에서 기본적으로 제공되는 에러 클래스들이 많지만, 개발자가 직접 에러 클래스를 정의하고 싶을 수도 있다. 그때 생성하는 것이 사용자 예외 클래스이다. 이 클래스는 Exception 클래스를 상속하며 클래스명은 Exception으로 끝난다.

---

모든 예외를 if문으로 처리해놨던 클래스들을 에러처리를 해보았다. 방법은 여러가지였다. 각 메소드에서 try-catch문으로 직접 처리하거나, throws를 이용해서 예외를 메소드 호출 부분으로 던져서 해결하거나, 사용자 정의 예외 클래스를 직접 만들어서 에러 처리하는 방법 등이 있다.

첫번째와 두번째 방법은 마지막 방법보다는 이해하기 좀 더 쉬웠다. 에러를 받으면 그 부분에서 무조건 해결하는 것이 아니라 거기서 받은 에러를 다시 다른 곳으로 던지는 개념이 좀 와닿지는 않았으나, 코드를 직접 작성해보니까 어떤 느낌인지 알게 되었다.

그런데 문제는 사용자 정의 예외 클래스를 생성해서 예외처리를 하는 방법이었다.

기존의 클래스가 아닌, 특정 에러에 해당하는 예외 클래스들을 직접 정의해서 만들어주는데, 클래스 들 사이를 왔다갔다 하면서 에러를 받아서 처리하는 부분도 까다로웠다… 예외처리에 대해서 더 많은 공부가 필요할 것 같다.